# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-29T11:55:25+00:00

from __future__ import annotations

from enum import Enum
from typing import Any, Dict, List, Optional

from pydantic import BaseModel, Field


class Attribute(BaseModel):
    key: Optional[str] = Field(None, description='Facet key.')
    labelKey: Optional[str] = Field(
        None, description='Human-readable format of the facet key.'
    )
    labelValue: Optional[str] = Field(
        None, description='Human-readable format of the facet value.'
    )
    value: Optional[str] = Field(None, description='Facet value.')


class Search(BaseModel):
    attributes: Optional[List[Attribute]] = Field(
        None, description='List of facets in which the term can be searched.'
    )
    count: Optional[float] = Field(
        None, description='Number of times the term was searched.'
    )
    term: Optional[str] = Field(None, description='Search term.')


class AutocompleteSearchSuggestions(BaseModel):
    searches: Optional[List[Search]] = Field(
        None, description='List of suggested facets and terms.'
    )


class Banner(BaseModel):
    area: Optional[str] = Field(None, description='Banner area.')
    html: Optional[str] = Field(None, description='Banner HTML.')
    id: Optional[str] = Field(None, description='Banner id.')
    name: Optional[str] = Field(None, description='Banner name.')


class Banners(BaseModel):
    banners: Optional[List[Banner]] = None


class Correction1(BaseModel):
    correction: Optional[bool] = Field(
        None,
        description='Whether the API was able to suggest a correction (`true`) or not (`false`).',
    )
    highlighted: Optional[str] = Field(
        None,
        description='The same as `text`, but it highlights the corrected word. Useful when there is more than one word.',
    )
    misspelled: Optional[bool] = Field(
        None, description='Whether the term was misspelled (`true`) or not (`false`).'
    )
    text: Optional[str] = Field(
        None,
        description='The corrected term. If the API was not able to correct the term, it will show the original search term.',
    )


class Correction(BaseModel):
    correction: Optional[Correction1] = Field(
        None,
        description='Object that indicates if the term was misspelled and suggests a possible correction.',
    )


class Error(BaseModel):
    message: str = Field(..., description='Error message')
    stack: str = Field(..., description='Error stack trace')


class BreadcrumbItem(BaseModel):
    href: Optional[str] = Field(None, description='Query link.')
    name: Optional[str] = Field(
        None, description='Human-readable format of the facet key.'
    )


class Type(Enum):
    TEXT = 'TEXT'
    PRICERANGE = 'PRICERANGE'


class Value(BaseModel):
    id: Optional[str] = Field(None, description='Value id')
    key: Optional[str] = Field(None, description='Facet key.')
    name: Optional[str] = Field(
        None, description='Human-readable format of the facet value'
    )
    quantity: Optional[float] = Field(None, description='Number of resulting products.')
    selected: Optional[bool] = Field(
        None, description='Whether the value is selected (`true`) or not (`false`).'
    )
    value: Optional[str] = Field(None, description='Facet value.')


class Facet(BaseModel):
    hidden: Optional[bool] = Field(
        None,
        description='Whether the client-side should hide the facet (`true`) or not (`false`)',
    )
    name: Optional[str] = Field(
        None, description='Human-readable format of the facet key.'
    )
    quantity: Optional[float] = Field(None, description='Number of possible values.')
    type: Optional[Type] = Field(
        None,
        description='Facet type\n - `TEXT` - The value is a simple text.\n - `PRICERANGE` - The value contains the property `range` representing the minimum and the maximum price for the query.\n',
    )
    values: Optional[List[Value]] = Field(None, description='Possible values.')


class SelectedFacet(BaseModel):
    key: Optional[str] = Field(None, description='facet key.')
    value: Optional[str] = Field(None, description='facet value.')


class QueryArgs(BaseModel):
    query: Optional[str] = Field(None, description='Search term used in the query.')
    selectedFacets: Optional[List[SelectedFacet]] = Field(
        None, description='Facets used in the query.'
    )


class Facets(BaseModel):
    breadcrumb: Optional[List[BreadcrumbItem]] = Field(
        None, description='Generated breadcrumb for the given query.'
    )
    facets: Optional[List[Facet]] = Field(None, description='List of facets')
    queryArgs: Optional[QueryArgs] = Field(
        None, description='Term and facets used in the query'
    )
    sampling: Optional[bool] = Field(
        None,
        description='Indicates whether there was sampling in the aggregation of facets or not. In search results that have many products, only the first 30000 will be aggregated to avoid performance issues.',
    )


class Correction2(BaseModel):
    misspelled: Optional[bool] = Field(
        None, description='Whether the term is misspelled (`true`) or not (`false`).'
    )


class Operator(Enum):
    and_ = 'and'
    or_ = 'or'


class ProductSearch(BaseModel):
    correction: Optional[Correction2] = Field(
        None, description='Object with information of misspelled terms.'
    )
    fuzzy: Optional[str] = Field(
        None,
        description='Indicates how the search engine corrected the misspelled word by using fuzzy logic. It can be a number representing the max number of misspelled letters, or the string `auto` suggesting that the search-engine should set this value by itself.',
    )
    operator: Optional[Operator] = Field(
        None,
        description='Indicates how the search-engine dealt with the fullText when there is more than one word.\n * `and` - It means that the products contains all the words in the query.\n * `or` - It means that the results will contain at least one word from the original search query. If `and` was not possible, `or` will be the fallback.',
    )
    products: Optional[List[Dict[str, Any]]] = Field(
        None, description='List of products'
    )
    recordsFiltered: Optional[float] = Field(
        None, description='Total number of products.'
    )
    translated: Optional[bool] = Field(
        None,
        description='Whether the list of products was translated by the IS (`true`) or not (`false`).',
    )


class Search1(BaseModel):
    count: Optional[float] = Field(
        None, description='Number of times the term was searched.'
    )
    term: Optional[str] = Field(None, description='Search term.')


class SearchSuggestions(BaseModel):
    searches: Optional[List[Search1]] = Field(
        None, description='List of suggested terms.'
    )


class TopSearches(BaseModel):
    searches: Optional[List[Search1]] = Field(
        None,
        description='A list of the 10 most searched terms.',
        max_length=10,
        min_length=10,
    )


class SimulationBehavior(Enum):
    default = 'default'
    skip = 'skip'
    only1P = 'only1P'


class Sort(Enum):
    price_desc = 'price:desc'
    price_asc = 'price:asc'
    orders_desc = 'orders:desc'
    name_desc = 'name:desc'
    name_asc = 'name:asc'
    release_desc = 'release:desc'
    discount_desc = 'discount:desc'
